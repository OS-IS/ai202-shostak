# Визначення точки входу програми

## Огляд

Перерахування програми та її поверхні атаки є ключовим попередником перед проведенням будь-якого ретельного тестування, оскільки це дозволяє тестувальнику визначити ймовірні слабкі місця. Цей розділ має на меті допомогти визначити та нанести на карту області в межах програми, які слід дослідити після завершення перерахування та відображення.

## Цілі тестування

- Визначити можливі точки входу та ін'єкції за допомогою аналізу запитів та відповідей.

## Як тестувати

Перед початком тестування тестувальник завжди повинен добре розуміти додаток і те, як користувач і браузер взаємодіють з ним. Під час роботи з додатком тестувальник повинен звертати увагу на всі HTTP-запити, а також на кожен параметр і поле форми, які передаються в додаток. Особливу увагу слід звертати на те, коли використовуються GET-запити, а коли - POST-запити для передачі параметрів додатку. Крім того, вони також повинні звертати увагу на те, коли використовуються інші методи для RESTful сервісів.

Зверніть увагу, що для того, щоб побачити параметри, відправлені в тілі запитів, таких як POST-запит, тестувальник може захотіти скористатися таким інструментом, як перехоплюючий проксі-сервер (See [tools](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/06-Identify_Application_Entry_Points#tools)). У POST-запиті тестувальник також повинен звернути особливу увагу на будь-які приховані поля форми, які передаються додатку, оскільки вони зазвичай містять конфіденційну інформацію, таку як інформація про стан, кількість товарів, ціна товарів, яку розробник ніколи не хотів, щоб хтось бачив або змінював.

З досвіду автора, на цьому етапі тестування дуже корисно використовувати перехоплюючий проксі та електронну таблицю. Проксі буде відстежувати кожен запит і відповідь між тестувальником і додатком під час його дослідження. Крім того, на цьому етапі тестувальники зазвичай перехоплюють кожен запит і відповідь, щоб бачити кожен заголовок, параметр і т.д., які передаються додатку і що повертається. Іноді це може бути досить нудно, особливо на великих інтерактивних сайтах (уявіть собі банківський додаток). Однак досвід покаже, на що звертати увагу, і цей етап можна значно скоротити.

Коли тестувальник переглядає додаток, він повинен занотовувати будь-які цікаві параметри в URL-адресі, спеціальних заголовках або тілі запитів/відповідей і зберігати їх в електронній таблиці. Таблиця повинна містити запитувану сторінку (було б добре також додати номер запиту від проксі-сервера для подальшого використання), цікаві параметри, тип запиту (GET, POST тощо), чи є доступ автентифікованим/неавторизованим, чи використовується TLS, чи є це частиною багатоетапного процесу, чи використовуються WebSockers, а також будь-які інші відповідні примітки. Після того, як вони визначили кожну область додатку, вони можуть пройти через додаток і протестувати кожну з областей, які вони визначили, і зробити нотатки про те, що працювало, а що не працювало. Далі в цьому посібнику буде описано, як протестувати кожну з цих сфер, але цей розділ має бути прочитаний до того, як розпочнеться власне тестування.

Нижче наведено деякі цікаві моменти для всіх запитів і відповідей. У розділі запитів зосередьтеся на методах GET і POST, оскільки вони використовуються в більшості запитів. Зауважте, що можна використовувати й інші методи, такі як PUT і DELETE. Часто ці більш рідкісні запити, якщо вони дозволені, можуть виявити уразливості. У цьому посібнику є спеціальний розділ, присвячений тестуванню цих методів HTTP.

#### Запити

- Визначте, де використовуються GET-запити, а де POST-запити.

- Визначте всі параметри, що використовуються в POST-запиті (вони знаходяться в тілі запиту).

- У POST-запиті зверніть особливу увагу на будь-які приховані параметри. При відправці POST-запиту всі поля форми (включно з прихованими параметрами) будуть відправлені в тілі HTTP-повідомлення до програми. Зазвичай їх не видно, якщо не використовується проксі-сервер або не переглядається вихідний код HTML. Крім того, наступна сторінка, дані на ній і рівень доступу можуть відрізнятися залежно від значення прихованого параметра (параметрів).

- Визначте всі параметри, використані в GET-запиті (тобто URL-адресу), зокрема рядок запиту (зазвичай після знака ?).

- Визначте всі параметри рядка запиту. Зазвичай вони мають парний формат, наприклад, `foo=bar`. Також зверніть увагу, що багато параметрів можуть бути в одному рядку запиту, наприклад, розділені символами  a `&`, `\~`, `:`, або будь-яким іншим спеціальним символом чи кодуванням.

- Особлива увага при визначенні декількох параметрів в одному рядку або в POST-запиті полягає в тому, що деякі або всі параметри можуть знадобитися для виконання атаки. Тестувальник повинен визначити всі параметри (навіть якщо вони закодовані або зашифровані) і визначити, які з них обробляються додатком. У наступних розділах посібника буде описано, як перевірити ці параметри. На цьому етапі просто переконайтеся, що кожен з них ідентифікований.

- Також зверніть увагу на будь-які додаткові або спеціальні заголовки, які зазвичай не зустрічаються (наприклад, `debug: false`).

### Відповіді

- Визначте, де встановлюються (заголовок `Set-Cookie`), змінюються або додаються нові файли cookie.

- Визначте, де є перенаправлення (код стану HTTP 3xx), коди стану 400, зокрема 403 Заборонено, і 500 внутрішніх помилок сервера під час звичайних відповідей (тобто, незмінених запитів).

- Також зверніть увагу, де використовуються цікаві заголовки. Наприклад, `Server: BIG-IP` вказує на те, що сайт збалансований за навантаженням. Таким чином, якщо сайт збалансований і один з серверів неправильно налаштований, то тестеру, можливо, доведеться зробити кілька запитів, щоб отримати доступ до вразливого сервера, в залежності від типу балансування навантаження, що використовується.

### Тестування чорної скриньки

####Тестування на наявність точок входу до програми

Нижче наведено два приклади того, як перевірити наявність точок входу в додаток.

#### Приклад 1

У цьому прикладі показано GET-запит, який має на меті придбати товар у додатку для онлайн-покупок.

```
GET /shoppingApp/buyme.asp?CUSTOMERID=100&ITEM=z101a&PRICE=62.50&IP=x.x.x.x HTTP/1.1
Host: x.x.x.x
Cookie: SESSIONID=Z29vZCBqb2IgcGFkYXdhIG15IHVzZXJuYW1lIGlzIGZvbyBhbmQgcGFzc3dvcmQgaXMgYmFy
```

*Тут тестувальник відзначить всі параметри запиту, такі як CUSTOMERID, ITEM, PRICE, IP і Cookie (які можуть бути просто закодованими параметрами або використовуватися для позначення стану сесії).*

#### Приклад 2

У цьому прикладі показано POST-запит, який дозволить вам увійти в додаток.

```
POST /KevinNotSoGoodApp/authenticate.asp?service=login HTTP/1.1
Host: x.x.x.x
Cookie: SESSIONID=dGhpcyBpcyBhIGJhZCBhcHAgdGhhdCBzZXRzIHByZWRpY3RhYmxlIGNvb2tpZXMgYW5kIG1pbmUgaXMgMTIzNA==;CustomCookie=00my00trusted00ip00is00x.x.x.x00

user=admin&pass=pass123&debug=true&fromtrustIP=true
```

*In this example the tester would note all the parameters as they have before, however the majority of the parameters are passed in the body of the request and not in the URL. Additionally, note that there is a custom HTTP header (`CustomCookie`) being used.*

### Тестування за методом сірої скриньки

Тестування точок входу в додаток за допомогою методології сірого ящика складається з усього, що вже було описано вище, з одним доповненням. У випадках, коли є зовнішні джерела, з яких додаток отримує дані та обробляє їх (наприклад, пастки SNMP, повідомлення syslog, SMTP або SOAP з інших серверів), зустріч з розробниками додатку може визначити будь-які функції, які приймають або очікують введення даних користувачем, а також те, як вони відформатовані. Наприклад, розробник може допомогти зрозуміти, як правильно сформулювати SOAP-запит, який додаток прийме, і де знаходиться веб-сервіс (якщо веб-сервіс або будь-яка інша функція ще не була визначена під час тестування «чорного ящика»).

#### OWASP Attack Surface Detector

Інструмент Attack Surface Detector (ASD) досліджує вихідний код і виявляє кінцеві точки веб-додатку, параметри, які ці кінцеві точки приймають, і тип даних цих параметрів. Сюди входять незв'язані кінцеві точки, які павук не зможе знайти, або необов'язкові параметри, які повністю не використовуються в клієнтському коді. Він також має можливість обчислювати зміни в поверхні атаки між двома версіями програми.

Детектор поверхні атаки доступний як плагін до ZAP і Burp Suite, а також як інструмент командного рядка. Інструмент командного рядка експортує поверхню атаки у форматі JSON, який потім може бути використаний плагінами ZAP і Burp Suite. Це корисно у випадках, коли вихідний код не надається тестеру проникнення безпосередньо. Наприклад, тестер проникнення може отримати вихідний файл у форматі JSON від клієнта, який не бажає надавати сам вихідний код.

##### Як користуватися

JAR-файл CLI можна завантажити за посиланням https://github.com/secdec/attack-surface-detector-cli/releases.

Ви можете запустити наступну команду для ASD, щоб визначити кінцеві точки з вихідного коду цільової веб-програми.

`java -jar attack-surface-detector-cli-1.3.5.jar <шлях до вихідного коду> [прапори]`

Ось приклад запуску команди для [OWASP RailsGoat](https://github.com/OWASP/railsgoat).

```
 
$ java -jar attack-surface-detector-cli-1.3.5.jar railsgoat/
Початок виявлення кінцевих точок для '<...>/railsgoat' з 1 типом фреймворку
Використовуючи framework=RAILS
[0] GET: /login (0 варіантів): PARAMETERS={url=name=url, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/sessions_contro
ller.rb (рядки '6'-'9')
[1] GET: /logout (0 варіантів): PARAMETERS={}; FILE=/app/controllers/sessions_controller.rb (рядки '33'-'37')
[2] POST: /forgot_password (0 варіантів): PARAMETERS={email=name=email, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/
password_resets_controller.rb (рядки '29'-'38')
[3] GET: /password_resets (0 варіантів): PARAMETERS={token=name=token, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/p
assword_resets_controller.rb (рядки '19'-'27')
[4] POST: /password_resets (0 варіантів): PARAMETERS={password=name=password, paramType=QUERY_STRING, dataType=STRING, user=name=user, paramType=QUERY_STRING, dataType=STRING, confirm_password=name=confirm_password, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/password_resets_controller.rb (рядки '5'-'17')
[5] GET: /sessions/new (0 варіантів): PARAMETERS={url=name=url, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/sessions_controller.rb (рядки '6'-'9')
[6] POST: /sessions (0 варіантів): PARAMETERS={password=name=пароль, paramType=QUERY_STRING, dataType=STRING, user_id=name=user_id, paramType=SESSION, dataType=STRING, remember_me=name=запам'ятати_мене, paramType=QUERY_STRING, dataType=STRING, url=name=url, paramType=QUERY_STRING, dataType=STRING, email=name=email, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/sessions_controller. rb (рядки '11'-'31')
[7] DELETE: /sessions/{id} (0 варіантів): PARAMETERS={}; FILE=/app/controllers/sessions_controller.rb (рядки '33'-'37')
[8] GET: /users (0 варіантів): PARAMETERS={}; FILE=/app/controllers/api/v1/users_controller.rb (рядки '9'-'11')
[9] GET: /users/{id} (0 варіантів): PARAMETERS={}; FILE=/app/controllers/api/v1/users_controller.rb (рядки '13'-'15')
... snipped ...
[38] GET: /api/v1/mobile/{id} (0 варіантів): PARAMETERS={id=name=id, paramType=QUERY_STRING, dataType=STRING, class=name=class, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/api/v1/mobile_controller.rb (рядки '8'-'13')
[39] GET: / (0 варіантів): PARAMETERS={url=name=url, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/sessions_controller.rb (рядки '6'-'9')
Згенеровано 40 різних кінцевих точок з 0 варіантами, загалом 40 кінцевих точок
Успішно перевірено серіалізацію для цих кінцевих точок
0 кінцевих точок не мали початкового рядка коду
0 кінцевих точок не мали кінцевого рядка коду
0 кінцевих точок мали однакові початковий та кінцевий рядки коду
Згенеровано 36 різних параметрів
Згенеровано 36 загальних параметрів
- 36/36 мають свій тип даних
- 0/36 мають список допустимих значень
- 36/36 мають тип параметра
--- QUERY_STRING: 35
--- SESSION: 1
Завершено визначення кінцевої точки для '<...>/railsgoat'
----------
-- ВИКОНАНО --
0 проектів мали повторювані кінцеві точки
Згенеровано 40 різних кінцевих точок
Згенеровано 40 загальних кінцевих точок
Згенеровано 36 різних параметрів
Згенеровано 36 загальних параметрів
У 1/1 проектів згенеровано кінцеві точки
Щоб увімкнути ведення журналу, додайте аргумент -debug
```

Ви також можете згенерувати вихідний файл у форматі JSON за допомогою прапорця `-json`, який може бути використаний плагіном як для ZAP, так і для Burp Suite. Дивіться наступні посилання для більш детальної інформації.

- [Головна сторінка плагіна ASD для OWASP ZAP](https://github.com/secdec/attack-surface-detector-zap/wiki)
- [Головна сторінка плагіна ASD для PortSwigger Burp](https://github.com/secdec/attack-surface-detector-burp/wiki)


## Інструменти

- [OWASP Zed Attack Proxy (ZAP)](https://www.zaproxy.org/)

- [Burp Suite](https://www.portswigger.net/burp/)

- [Fiddler](https://www.telerik.com/fiddler)

## Посилання

- [RFC 2616 - Протокол передачі гіпертексту - HTTP 1.1](https://tools.ietf.org/html/rfc2616)

- [Детектор поверхневих атак OWASP] (https://owasp.org/www-project-attack-surface-detector/)